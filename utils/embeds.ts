import {
    ActionRowBuilder,
    ButtonBuilder,
    CommandInteraction,
    EmbedBuilder,
    ButtonStyle,
    MessageFlags
} from 'discord.js';


// TODO?
export function textEmbed(desc: string) {
    return new EmbedBuilder()
        .setDescription(desc)
        .setColor('#C61130')
}

/**
 * Replies to an interaction with a multi-embed, paginated message.
 * @param target The `Message` or `CommandInteraction` to reply to.
 * @param pages The pages of the message, represented by an array of embeds.
 */
export async function paginate(target: CommandInteraction, pages: EmbedBuilder[]) {
    if (!pages.length) return;
    if (pages.length === 1) return target.reply({ embeds: [pages[0]] });

    let index = 0;

    // TODO: change middle "button" page indicator to select menu
    const buttonRow = new ActionRowBuilder<ButtonBuilder>().addComponents(
        new ButtonBuilder()
            .setCustomId('first')
            .setLabel('⏮️')
            .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
            .setCustomId('previous')
            .setLabel('◀️')
            .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
            .setCustomId('counter')
            .setLabel((index + 1).toString())
            .setDisabled(true)
            .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
            .setCustomId('next')
            .setLabel('▶️')
            .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
            .setCustomId('last')
            .setLabel('⏭️')
            .setStyle(ButtonStyle.Secondary),
    );

    const pagedMessage = await target.reply({ embeds: [pages[0]], components: [buttonRow] });
    const collector = pagedMessage.createMessageComponentCollector({ time: 30000 });

    collector.on('collect', (i) => {
        // If the interaction was not generated by the original message author, inform them they are not allowed to switch pages
        if (i.user.id !== target.user.id) return void i.reply({
            embeds: [textEmbed('Not allowed to switch pages on this command.')],
            flags: MessageFlags.Ephemeral
        });

        // Defer component loading to prevent "This interaction failed"
        i.deferUpdate();

        switch (i.customId) {
            case 'first':
                index = 0;
                break;
            case 'previous':
                index = index === 0 ? pages.length - 1 : index - 1;
                break;
            case 'next':
                index = (index + 1) % pages.length;
                break;
            case 'last':
                index = pages.length - 1;
                break;
        }
        buttonRow.components[2].setLabel((index + 1).toString());
        pagedMessage.edit({ embeds: [pages[index]], components: [buttonRow] });
    });

    // Disable all buttons on timeout
    collector.on('end', () => {
        buttonRow.components.forEach((x) => x.setDisabled(true));
        pagedMessage.edit({ embeds: [pages[index]], components: [buttonRow] });
    });
}
